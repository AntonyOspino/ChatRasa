from rasa_sdk import Action, Tracker
from rasa_sdk.executor import CollectingDispatcher
from rasa_sdk.events import SlotSet
import psycopg2
from dotenv import load_dotenv
import os

# cargar variables de entorno .env
load_dotenv()
# otener la cadena de conexion
connection_string = os.getenv("NEON_CONNECTION_STRING")

def get_connection():
    return psycopg2.connect(connection_string)


# Usuario
# class ActionValidarUsuarioAPI(Action):
#     def name(self) -> Text:
#         return "action_validar_usuario_api"

#     def run(self, dispatcher: CollectingDispatcher, tracker: Tracker, domain: Dict[Text, Any]):
#         nombre_usuario = tracker.get_slot("nombre_usuario")
#         dispatcher.utter_message(text=f"Verificando usuario '{nombre_usuario}' en el sistema... (simulaci√≥n API)")
#         return []


# Citas
class ActionConsultarCita(Action):
    def name(self):
        return "action_consultar_cita"

    def run(self, dispatcher: CollectingDispatcher, tracker: Tracker, domain: dict):
        conn = None
        cursor = None
        try:
            identificacion = tracker.get_slot("identificacion")
            print(f" DEBUG - Identificacion en slot: {identificacion}")

            # Si no hay identificaci√≥n, intentar obtenerlo del √∫ltimo mensaje
            if not identificacion:
                texto = tracker.latest_message.get("text")
                if texto.isdigit() and len(texto) >= 6:
                    identificacion = texto

            if not identificacion or not identificacion.isdigit():
                dispatcher.utter_message(text="‚ö†Ô∏è Por favor, ingresa un n√∫mero de identificaci√≥n v√°lido (solo d√≠gitos).")
                return []

            conn = get_connection()
            cursor = conn.cursor()

            # Buscar el usuario con esa identificaci√≥n
            cursor.execute("""
                SELECT id FROM usuario WHERE identificacion = %s;
            """, (identificacion,))
            usuario = cursor.fetchone()

            if not usuario:
                dispatcher.utter_message(text="‚ùå No encontr√© ning√∫n usuario con esa identificaci√≥n.")
                return []

            usuario_id = usuario[0]

            # Buscar citas activas de ese usuario
            cursor.execute("""
                SELECT fecha_cita, hora_cita 
                FROM cita 
                WHERE usuario_paciente_id = %s 
                AND estado = 'Aprobada'
                ORDER BY fecha_cita ASC;
            """, (usuario_id,))

            citas = cursor.fetchall()

            if citas:
                mensajes = []
                for cita in citas:
                    fecha, hora = cita
                    mensajes.append(f"üìÖ {fecha} a las {hora}")
                if len(citas) == 1:
                    mensaje_final = f"Tienes una cita activa el {citas[0][0]} a las {citas[0][1]}"
                else:
                    mensaje_final = "Estas son tus citas activas:\n" + "\n".join(mensajes)
                dispatcher.utter_message(text=mensaje_final)
            else:
                dispatcher.utter_message(text="No tienes citas activas registradas üóìÔ∏è")
                
        except Exception as e:
            dispatcher.utter_message(text=f"‚ö†Ô∏è Error al consultar la base de datos: {e}")
        finally:
            if cursor:
                cursor.close()
            if conn:
                conn.close()

        return []



# Diagnosticos
# class ActionObtenerDiagnosticoAPI(Action):
#     def name(self) -> Text:
#         return "action_obtener_diagnostico_api"

#     def run(self, dispatcher: CollectingDispatcher, tracker: Tracker, domain: Dict[Text, Any]):
#         dispatcher.utter_message(text="Buscando tu diagn√≥stico m√°s reciente... (simulaci√≥n API)")
#         dispatcher.utter_message(text="√öltimo diagn√≥stico: presi√≥n arterial estable, continuar con dieta saludable.")
#         return []


# Medicos y notificaciones
class ActionConsultarDoctor(Action):
    def name(self):
        return "action_consultar_doctor"

    def run(self, dispatcher: CollectingDispatcher,
            tracker: Tracker,
            domain: dict):

        identificacion = tracker.get_slot("identificacion")

        # Si no hay identificaci√≥n, intentar obtenerlo del √∫ltimo mensaje
        if not identificacion or not identificacion.isdigit() or len(identificacion) < 6:
            texto = tracker.latest_message.get("text")
            if texto and texto.isdigit() and len(texto) >= 6:
                identificacion = texto

        if not identificacion or not identificacion.isdigit():
                dispatcher.utter_message(text="‚ö†Ô∏è Por favor, ingresa un n√∫mero de identificaci√≥n v√°lido (solo d√≠gitos).")
                return []

        try:
            # Conexi√≥n a PostgreSQL (ajusta tus credenciales si es necesario)
            conn = get_connection()
            cursor = conn.cursor()

            # 1Ô∏è‚É£ Buscar el ID del usuario (paciente)
            cursor.execute("""
                SELECT id FROM usuario WHERE identificacion = %s;
            """, (identificacion,))
            usuario = cursor.fetchone()

            if not usuario:
                dispatcher.utter_message(text="No encontr√© ning√∫n paciente con esa identificaci√≥n.")
                return []

            usuario_id = usuario[0]

            # 2Ô∏è‚É£ Buscar la cita m√°s reciente aprobada del paciente
            cursor.execute("""
                SELECT usuario_medico_id 
                FROM cita 
                WHERE usuario_paciente_id = %s AND estado = 'Aprobada'
                ORDER BY fecha_cita DESC, hora_cita DESC
                LIMIT 1;
            """, (usuario_id,))
            cita = cursor.fetchone()

            if not cita:
                dispatcher.utter_message(text="No tienes ninguna cita aprobada actualmente.")
                return []

            usuario_medico_id = cita[0]

            # 3Ô∏è‚É£ Obtener los datos del m√©dico
            cursor.execute("""
                SELECT nombre, apellido 
                FROM usuario 
                WHERE id = %s;
            """, (usuario_medico_id,))
            doctor = cursor.fetchone()

            if doctor:
                nombre_doctor = f"{doctor[0]} {doctor[1]}"
                dispatcher.utter_message(text=f"Tu m√©dico asignado es el Dr./Dra. {nombre_doctor} üë®‚Äç‚öïÔ∏è")
            else:
                dispatcher.utter_message(text="No encontr√© los datos del m√©dico asignado a tu cita.")

        except Exception as e:
            print("Error al consultar el doctor:", e)
            dispatcher.utter_message(text="Hubo un problema al consultar la informaci√≥n del m√©dico.")
        finally:
            if cursor:
                cursor.close()
            if conn:
                conn.close()

        return []


# Sistomas
# class ActionRecomendarSegunSintomas(Action):
#     def name(self) -> Text:
#         return "action_recomendar_seg√∫n_sintomas"

#     def run(self, dispatcher: CollectingDispatcher, tracker: Tracker, domain: Dict[Text, Any]):
#         sintoma = tracker.latest_message.get("text")
#         sintomas_usuario.append(sintoma)

#         # respuestas personalizadas
#         recomendaciones = {
#             "pecho": "El dolor en el pecho puede ser signo de angina o infarto. Evita esfuerzos y consulta un m√©dico.",
#             "mare": "El mareo puede estar asociado a baja presi√≥n o ritmo card√≠aco irregular.",
#             "palpit": "Las palpitaciones pueden deberse al estr√©s o arritmias. Evita cafe√≠na y mant√©n reposo.",
#             "presi√≥n": "Los cambios de presi√≥n afectan directamente al sistema cardiovascular. Controla tu tensi√≥n arterial.",
#             "falta de aire": "La falta de aire puede indicar insuficiencia card√≠aca o ansiedad.",
#             "hinchad": "La hinchaz√≥n en pies puede deberse a retenci√≥n de l√≠quidos o problemas card√≠acos."
#         }

#         texto = sintoma.lower()
#         recomendacion = "Te recomiendo mantener reposo y observar tus s√≠ntomas."
#         for palabra, respuesta in recomendaciones.items():
#             if palabra in texto:
#                 recomendacion = respuesta
#                 break

#         dispatcher.utter_message(text=f"Gracias por compartirlo. {recomendacion}")
#         return []
